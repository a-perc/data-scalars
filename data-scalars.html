<script src="../immutable/dist/immutable.min.js"></script>
<link rel="import" href="../polymer/polymer-element.html">
<link rel="import" href="../iron-input/iron-input.html">
<link rel="import" href="../vaadin-combo-box/vaadin-combo-box-light.html">

<!--
Automatic representation of a scalar value as Polymer Elements (Iron and Paper) – in either read-only or editable mode.

‹data-scalars› elements consume an immutable data egg data structure and produce suitable Polymer elements to represent that value. The data egg is a simple structure, which contains the scalar value, its type and logical formatting hints.

Designed to work hand-in-hand with data nuggets data structures delivered by ‹data-pipes›, although both can be used independently.

Example of usage:

  <data-point selector="coord" data="{{dataNugget}}" item="{{dataEgg}}">
    <data-scalars data="{{dataEgg}}" editable="true|false"></data-scalars>
  </data-point>
-->
<dom-module id="data-scalars">
  <template>
    <style>
      :host {
        display: block;
        @apply --layout-flex;
        @apply --layout-horizontal;
      }

      div.content {
        font-size: 12px;
        width: 100%;
        height: 23px;
        line-height: 23px;
        position: relative;
        box-sizing: border-box;
        border: 1px solid transparent; /* Make sure every cell have same height */
      }

      div.content.error {
        border: 1px solid rgb(255, 41, 41);
        background-color: rgb(248, 183, 183);
      }

      div[hidden]{
        display: none;
      }

      select,
      input,
      iron-input,
      vaadin-combo-box-light {
        --lumo-primary-text-color: red;
        font-family: inherit;
        height: 20px;
        width: 100%;
        box-sizing: border-box;
      }

      select[disabled],
      input[disabled]{
        border: none;
        background: transparent;
      }
    </style>
    <div id="scalar" class$="content [[_getErrorClass(data)]]" title="[[_title]]">
      <template is="dom-if" if="[[!editable]]">
        <div title="[[_computeTitle(data)]]">
          [[_formatValue(data, _value)]]
        </div>
      </template>

      <template is="dom-if" if="[[editable]]">
        <template is="dom-if" if="[[_isDataOfTypePrimitive(data)]]">
          <input
            class="input primitive"
            type$="[[_getType(data)]]"
            value="[[_value]]"
            disabled="[[disabled]]"
            on-change="_onChange">
        </template>

        <template is="dom-if" if="[[_isDataOfType(data, 'dropdown')]]">
          <template is="dom-if" if="[[!disabled]]">
            <vaadin-combo-box-light
              class="input dropdown"
              items="[[_suggestions]]"
              value="[[_value]]"
              attr-for-value="bind-value"
              on-value-changed="_onChange"
              allow-custom-value
              disabled="[[disabled]]">
              <template>
                <div style="font-size: 10px; font-family:'Roboto'">[[item.label]]</div>
              </template>
              <iron-input>
                <input disabled="[[disabled]]">
              </iron-input>
            </vaadin-combo-box-light>
          </template>
        </template>

        <template is="dom-if" if="[[_isDataOfType(data, 'checkbox')]]">
          <template is="dom-if" if="[[!disabled]]">
            <input
              class="input checkbox"
              type="checkbox"
              checked="[[_value]]"
              disabled="[[disabled]]"
              on-change="_onTick">
          </template>
        </template>
      </template>
    </div>
  </template>

  <script>
    /* jshint esversion:6, asi:true */
    /**
     * `data-scalars`
     * Automatic representation of a scalar value
     *
     * @customElement
     * @polymer
     * @demo demo/index.html
     */
    class DataScalars extends Polymer.Element {
      static get is() { return 'data-scalars'; }
      static get properties() {
        return {
          /**
           * The given `dataEgg`. A `dataEgg` is one element of the `dataNugget`.
           * Example:
           *
           *    dataEgg = {value: …, schema: …, format: … [, metadata: …]}
           */
          data: {
            type: Object,
            notify: true
          },


          /* Name of the data-scalar */
          name: {
            type: String,
          },

          /** Is this scalar editable or not ? (WIP) */
          editable: {
            type: Boolean,
            notify: true,
            value: false,
            reflectToAttribute: true
          },

          /** Is this scalar input disabled ? */
          disabled: {
            type: Boolean,
            notify: true,
            value: false,
            reflectToAttribute: true,
            observer: "_disabledChanged",
            computed: "_computeDisabled(data)"
          },

          /** Internal computed element type */
          _elementType: {
            type: String,
            value: "input"
          },


          /* Suggestions that are computed using the schema */
          _suggestions: {
            type: Array,
            computed: "_computeSuggestions( data)"
          },


          /* Internal computed value */
          _value: {
            type: String,
            computed: "_computeValue( data)"
          },

          _implementedTypes: {
            type: Array,
            value: () => {
              return ["text", "dropdown"];
            }
          },

          _title: {
            type: String,
            computed: "_computeTitle(data)"
          }
        };
      }

      ready() {
        super.ready();
      }

      /** Compute the `_value` and update its input field to make sure it is correct */
      _computeValue( data){
        if(!data){return}
        var value = data.get("value");
        if(value == undefined) { value = ""; }
        this._forceValue(value)
        return value;
      }

      _computeDisabled( data) {
        if(data.get("schema")){
          return data.get("schema").get("disabled") || false;
        } else {
          return false;
        }
      }

      /** Retrieves the suggestions from the schema */
      _computeSuggestions( data){
        if(!data){ return}
        if(data.get("schema") && data.get("schema").get("suggestions")){
          return data.get("schema").get("suggestions").toJS()
        }
      }

      /**
        * Compute the title that is display when hovering a field. If there is a specific error
        * in the schema, the error will be shown.
        */
      _computeTitle(data){
        if( !data) {return undefined; }
        if( !data.get("error")){ return data.get("value"); }
        return "Error: "+data.get("error");
      }

      /** Helpers */

      /** When `disabled` is changed, update the value to make sure it's correct in the input field */
      _disabledChanged(disabled){
        if(!this.data){return;}
        if(this._value) {
          // Make sure the value is updated when editing
          this._computeValue(this.data);
        }
      }

      /* Make sure that the user edition is deleted and replaced by the default value */
      _forceValue(value){
        var scalar = this.$.scalar;
        if(scalar) {
          var input = scalar.querySelector(".input");
          if(input){
            input.value = value;
          }
        }
        this._value = value;
      }

      /** If there is an error, the `error` class is returned to the input field */
      _getErrorClass(data){
        if(!data || !data.get("error")){return;}
        if(data.get("error")){
          return "error"
        }
      }

      /** Dispatch the 'change' event with the name and value of the component */
      _dispatchChangeEvent(value) {
        var event = new CustomEvent('change', {'detail': {name: this.name, value: value}})
        this.dispatchEvent(event);
      }

      /**
        * Dispatch a custom event 'change' when the input changes.
        * The event carries the name and value of the input in its details.
        *   {'detail': {name: "the name", value: "the value"}}
        */
      _onChange(e){
        this._dispatchChangeEvent(e.currentTarget.value)
      }

      /** Dispatch a custom event 'change' when the checkbox attribut has changed */
      _onTick(e){
        this._dispatchChangeEvent( e.currentTarget.checked)
      }

      /** Retrieves the type from the schema */
      _getType(data){
        if(data && data.get("schema") && data.get("schema").get("type")){
          return  data.get("schema").get("type");
        } else {
          return 'text';
        }
      }

      /**
        * Checks if the type, given from the schema, is an HTML primitive type.
        * This is used to know if we can use an HTML tag instead of a custom component
        * to present the data value.
        */
      _isDataOfTypePrimitive(data){
        var primitiveTypes = ['text', 'date', 'datetime-local', 'number'];
        var type = this._getType(data);
        if(type) {
          return primitiveTypes.indexOf( type) > -1;
        } else {
          return true;
        }
      }

      /**
        * Returns true if the data is of type `elType`.
        * By default and if the type is not specified, it will return true as if `elType` == 'text'
        */
      _isDataOfType(data, typeToCheck){
        var type = this._getType(data);
        if( ["bool", "checkbox", "boolean"].indexOf(type) > -1){
          type = "checkbox";
        }

        if(type){
          return type == typeToCheck;
        } else {
          return typeToCheck == 'text';
        }
      }

      _formatValue(data, value){
        if(!value){ return value; }
        var type = this._getType(data);
        if( ['date', 'datetime-local'].indexOf(type) > -1) {
          var date = new Date(value);
          var day = date.getDate()+"".length > 1 ? date.getDate() : '0'+date.getDate();
          var month = ((date.getMonth()+1)+"").length > 1 ? (date.getMonth()) : '0'+(date.getMonth()+1);
          var yearh = date.getFullYear();
          return year+"-"+month+"-"+day+" "+date.getHours()+":"+date.getMinutes();
        }
        return value;
      }
    }

    window.customElements.define(DataScalars.is, DataScalars);
  </script>
</dom-module>
