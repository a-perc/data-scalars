<script src="../immutable/dist/immutable.min.js"></script>
<link rel="import" href="../polymer/polymer-element.html">
<link rel="import" href="../iron-input/iron-input.html">
<link rel="import" href="../vaadin-combo-box/vaadin-combo-box-light.html">
<link rel="import" href="../flag-cc/flag-cc.html">

<!--
Automatic representation of a scalar value as Polymer Elements (Iron and Paper) – in either read-only or editable mode.

‹data-scalars› elements consume an immutable data egg data structure and produce suitable Polymer elements to represent that value. The data egg is a simple structure, which contains the scalar value, its type and logical formatting hints.

Designed to work hand-in-hand with data nuggets data structures delivered by ‹data-pipes›, although both can be used independently.

Example of usage:

  <data-point selector="coord" data="{{dataNugget}}" item="{{dataEgg}}">
    <data-scalars data="{{dataEgg}}" editable="true|false"></data-scalars>
  </data-point>
-->
<dom-module id="custom-vaadin-combo-box-item" theme-for="vaadin-combo-box-item">
  <template>
    <style>
      :host {
        padding: 0;
        margin: 0;
        max-height: 32px;
      }
      [part="content"] {
      }
      :host::before {
        display: none !important; /* Remove the blue-checkmark */
      }
    </style>
  </template>
</dom-module>
<dom-module id="data-scalars">
  <template>
    <style>
      :host {
        display: block;
        @apply --layout-flex;
        @apply --layout-horizontal;
      }
      :host([editable]) div.content {
        background-color: rgba(255, 255, 255, 0.1);
        border: 1px dotted gray;
      }

      div.content {
        font-size: 12px;
        color: inherit;
        width: 100%;
        height: 100%;
        position: relative;
        box-sizing: border-box;
        display: flex;
        align-items: center;
      }

      div.content.error {
        border: 1px solid rgb(255, 41, 41);
        background-color: rgb(248, 183, 183);
      }
      :host([editable]) div.content.error{
        border-style: dotted;
      }

      div.content .element {
        border: 1px solid transparent;
        padding: 0px 2px;
        background-color: transparent;
        width: 100%;
      }

      div.content .element.number {
        text-align: right;
      }
      div.content .element.financial {
        /** Nothing yet */
      }

      div[hidden]{
        display: none;
      }


      select,
      input,
      iron-input,
      vaadin-combo-box-light {
        color: inherit;
        font-family: inherit;
        width: 100%;
        box-sizing: border-box;
        font-weight: inherit;
      }

      vaadin-combo-box-ligh {
        min-width: 500px !important;
      }

      /** Turn off input[type=number] arrows/spiner */
      input[type=number]::-webkit-inner-spin-button,
      input[type=number]::-webkit-outer-spin-button {
        -webkit-appearance: none;
      }

      input,
      select,
      iron-input {
        outline: none;
        font-size: inherit;
        border: none;
      }

      /** Used for vaadin dropdown where the inner input shouldn't choose its background-color */
      iron-input input {
        background-color: transparent;
      }

      div.content[disabled],
      input[disabled],
      select[disabled] {
        border: none;
        background: transparent;
      }

      iron-icon {
        min-width: 20px;
        min-height: 20px;
      }

      .flag-cc-wrapper {
        width: 100%;
        height: 100%;
        display: flex;
        align-items: center;
        justify-content: center;
        padding: 1px;
      }
      flag-cc {
        width: 100%;
        height: 100%;
      }

    </style>
    <div id="scalar" class$="content [[_getErrorClass(data)]]" disabled$="[[disabled]]" title="[[_title]]">

      <!-- Icon -->
      <template is="dom-if" if="[[_isDataOfType(data, 'icon')]]">
        <template is="dom-if" if="[[editable]]">
          <input
              class$="input element [[_elementType]] [[_elementVariant]]"
              value="[[_value]]"
              title="[[_title]]"
              disabled="[[disabled]]"
              placeholder="[[placeholder]]"
              on-change="_onChange"
              on-keyup="_onKeyup"
              on-keydown="_onKeydown"
          >
        </template>
        <template is="dom-if" if="[[!editable]]">
          <template is="dom-if" if="[[__equals(_elementVariant, 'default')]]">
            <iron-icon icon$="[[_getIconName(_suggestionsByLabel, _value)]]"></iron-icon>
          </template>
          <template is="dom-if" if="[[__equals(_elementVariant, 'flag')]]">
            <div class="flag-cc-wrapper">
              <flag-cc currency="[[_value]]"></flag-cc>
            </div>
          </template>
        </template>
      </template>

      <!-- Text value -->
      <template is="dom-if" if="[[_shouldShowValue(data)]]">
        <span style="display: none">[[_value]]</span> <!-- In order to correctly us the DOM sort (eg: vaadin grid) -->
        <template is="dom-if" if="[[!editable]]">
          <div style="[[_getTextStyle(data, _value)]]" title="[[_computeTitle(data)]]" class$="element [[_elementType]] [[_elementVariant]]">
            [[_formatValue(data, _value, _suggestions)]]
          </div>
        </template>
      </template>

      <!-- EDITABLE MODE -->
      <template is="dom-if" if="[[editable]]">

        <!-- Editable primitive value -->
        <template is="dom-if" if="[[_isDataOfTypePrimitive(data)]]">
          <template is="dom-if" if="[[!disabled]]">
            <input
                class$="input element [[_elementType]] [[_elementVariant]]"
                type$="[[_getType(data)]]"
                value$="[[_value]]"
                title="[[_title]]"
                disabled="[[disabled]]"
                placeholder="[[placeholder]]"
                on-change="_onChange"
                on-keyup="_onKeyup"
                on-keydown="_onKeydown"
            >
          </template>
          <template is="dom-if" if="[[disabled]]">
            [[_formatValue(data, _value, _suggestions)]]
          </template>
        </template>

        <!-- Editable date and timestamp value -->
        <template is="dom-if" if="[[_isDataOfTypeDate(data)]]">
          <template is="dom-if" if="[[!disabled]]">
            <input
                class$="input element [[_elementType]] [[_elementVariant]]"
                type$="[[_parseHTMLDateType(data)]]"
                value$="[[_formatHTMLDatetime(data, _value)]]"
                title="[[_title]]"
                disabled="[[disabled]]"
                placeholder="[[placeholder]]"
                on-change="_onChange"
                on-keyup="_onKeyup"
                on-keydown="_onKeydown"
            >
          </template>
          <template is="dom-if" if="[[disabled]]">
            [[_formatValue(data, _value, _suggestions)]]
          </template>
        </template>

        <!-- Editable dropdown -->
        <template is="dom-if" if="[[_isDataOfType(data, 'dropdown')]]">
          <template is="dom-if" if="[[!disabled]]">
            <vaadin-combo-box-light
              class$="input element dropdown [[_elementType]] [[_elementVariant]]"
              placeholder="[[placeholder]]"
              items="[[_suggestions]]"
              value="[[_getLabelFromValue(_suggestions, _value)]]"
              attr-for-value="bind-value"
              on-value-changed="_onChange"
              allow-custom-value
              disabled="[[disabled]]">
              <template>
                <div style="font-size: 10px; font-family:'Roboto';">[[item.label]] ([[item.value]])</div>
              </template>
              <iron-input>
                <input
                    placeholder="[[placeholder]]"
                    disabled$="[[disabled]]"
                    on-keyup="_onKeyup"
                    on-keydown="_onKeydown"
                >
              </iron-input>
            </vaadin-combo-box-light>
          </template>
        </template>

        <!-- Editable checkbox -->
        <template is="dom-if" if="[[_isDataOfType(data, 'checkbox')]]">
          <template is="dom-if" if="[[!disabled]]">
            <select
                class$="input element checkbox [[_elementType]] [[_elementVariant]]"
                disabled="[[disabled]]"
                on-change="_onTick"
                value="[[_value]]"
                on-keyup="_onKeyup"
            >
              <option>undefined</option>
              <option value=true>true</option>
              <option value=false>false</option>
            </select>
          </template>
          <template is="dom-if" if="[[disabled]]">
            [[_value]]
          </template>
        </template>
      </template>
    </div>
  </template>

  <script>
    /* jshint esversion:6, asi:true */
    /**
     * `data-scalars`
     * Automatic representation of a scalar value
     *
     * @customElement
     * @polymer
     * @demo demo/index.html
     */
    class DataScalars extends Polymer.Element {
      static get is() { return 'data-scalars'; }
      static get properties() {
        return {
          /**
           * The given `dataEgg`. A `dataEgg` is one element of the `dataNugget`.
           * Example:
           *
           * ```
           *    dataEgg = {value: …, schema: …, format: … [, metadata: …]}
           *
           *    schema = {
           *      editable: true|false,
           *      type: text|number|date|boolean|dropdown,
           *      variant: ...,
           *      hidden: true|false,
           *
           *    schema.variant = << depends on schema.type >>
           *      text:   default
           *      number: financial|default;
           *      date:   default
           * ```
           */
          data: {
            type: Object,
            notify: true
          },


          /* Name of the data-scalar */
          name: {
            type: String,
          },

          /** Is this scalar editable or not ? (WIP) */
          editable: {
            type: Boolean,
            notify: true,
            value: false,
            reflectToAttribute: true
          },

          /** Is this scalar input disabled ? */
          disabled: {
            type: Boolean,
            notify: true,
            value: false,
            reflectToAttribute: true,
            observer: "_disabledChanged",
            computed: "_computeDisabled(data)"
          },

          /** Placeholder for the field */
          placeholder: {
            type: String
          },

          /** Internal computed element type */
          _elementType: {
            type: String,
            value: "text",
            computed: "_computeElementType(data)"
          },

          /** Internal computed element variant type */
          _elementVariant: {
            type: String,
            value: "default",
            computed: "_computeElementVariant(data)"
          },


          /**
           * Suggestions that are computed from the schema
           * eg: [{label: …, value:…}, …]
           */
          _suggestions: {
            type: Array,
            computed: "_computeSuggestions( data)"
          },

          /**
           * Suggestions object structured by `label`
           * eg: {"label1": "value1", "label2": "value2", …}
           */
          _suggestionsByLabel: {
            type: Object,
            computed: "_computeSuggestionsByLabel( _suggestions)"
          },

          /** Internal computed value */
          _value: {
            type: String,
            computed: "_computeValue( data)"
          },

          /** Internal computed tooltip title */
          _title: {
            type: String,
            computed: "_computeTitle(data, title)"
          },

          __previousOnChangeValue: {
            type: String,
            value: ""
          }
        };
      }

      ready() {
        super.ready();
      }

      /** Compute the `_value` and update its input field to make sure it is correct */
      _computeValue( data){
        if(!data){return}
        var value = data.get("value");

        // Translate undefined to empty string
        if(value == undefined) { value = ""; }

        // Make sure to refresh the input field when the current user
        // is not editing the field.
        // NOTE: if the underlying data changed and the user is editing,
        //       the input field value should NOT be updated.
        if(!this.editable){ this._forceValue( value); }

        return value;
      }

      /** Computes the disable option from the schema */
      _computeDisabled( data) {
        if(data.get("schema")){
          return data.get("schema").get("disabled") || false;
        }
        return false;
      }

      /** Computes the suggestions from the schema */
      _computeSuggestions( data){
        if(!data){ return}
        if(data.get("schema") && data.get("schema").get("suggestions")){
          return data.get("schema").get("suggestions").toJS()
        }
      }

      /** Computes the suggestions scrutured by 'label' */
      _computeSuggestionsByLabel( _suggestions) {
        var result = {};
        if(_suggestions) {
          _suggestions.forEach( (sug) => {
            result[sug.label] = sug.value;
          });
        }
        return result;
      }

      /**
        * Computes the title that is display when hovering a field. If there is a specific error
        * in the schema, the error will be shown.
        */
      _computeTitle(data, title){
        if( title != undefined){ return title; }
        if( !data) {return undefined; }
        if( !data.get("error")){ return data.get("value"); }
        return "Error: "+data.get("error");
      }

      /** Computes the element type from the schema */
      _computeElementType( data) {
        return this._getType( data);
      }

      /** Computes the element variant type from the schema */
      _computeElementVariant( data) {
        return this._getVariant( data);
      }

      /** Helpers */

      /** When `disabled` is changed, update the value to make sure it's correct in the input field */
      _disabledChanged(disabled){
        if(!this.data){return;}
        if(this._value) {
          // Make sure the value is updated when editing
          this._computeValue(this.data);
        }
      }

      /* Make sure that the user edition is deleted and replaced by the default value */
      _forceValue(value){
        var scalar = this.$.scalar;
        if(scalar) {
          var input = scalar.querySelector(".input");
          if(input){
            input.value = value;
          }
        }
        this._value = value;
      }

      /** If there is an error, the `error` class is returned to the input field */
      _getErrorClass(data){
        if(!data || !data.get("error")){return;}
        if(data.get("error")){
          return "error"
        }
      }

      /** Dispatch the 'change' event with the name and value of the component */
      _dispatchChangeEvent(value) {
        var event = new CustomEvent('change', {'detail': {name: this.name, value: value}})
        this.dispatchEvent(event);
      }

      /**
        * Dispatch a custom event 'change' when the input changes.
        * The event carries the name and value of the input in its details.
        *   {'detail': {name: "the name", value: "the value"}}
        */
      _onChange(e){
        var value = e.currentTarget.value;
        if(e.currentTarget.type == "datetime-local"){
          value = value.replace("T", " ");
        }
        if(this.__previousOnChangeValue != value){
          this._dispatchChangeEvent( value)
          this.__previousOnChangeValue = value;
        }
      }

      _onKeyup(e) {
        this._onChange(e); // Make sure we capture the last onchange event
      }

      /**
       * Dispatch an event when some special keys are used.
       * Eg:
       *     - Escape key will dispatch the 'cancel' event
       *     - Enter key will dispatch the 'validate' event
       */
      _onKeydown(e) {
        if(e.ctrlKey && e.keyCode == 13) {
          e.stopPropagation();
          e.preventDefault();
          var event = new Event('validate');
          this.dispatchEvent(event);
        } else if (e.code == "Escape") {
          var event = new Event('cancel');
          this.dispatchEvent(event);
        }
      }

      /** Dispatch a custom event 'change' when the checkbox attribut has changed */
      _onTick(e){
        var elem = e.currentTarget;
        var value = elem.options[elem.selectedIndex].value;
        var checked = undefined;
        if(value == "true"){checked = true;}
        else if(value == "false"){checked = false;}
        this._dispatchChangeEvent( checked);
      }

      /** Retrieves the type from the schema */
      _getType(data){
        if(data && data.get("schema") && data.get("schema").get("type")){
          return data.get("schema").get("type").toLowerCase();
        } else {
          return 'text';
        }
      }

      /** Retrieves the style from the schema */
      _getStyle(data){
        if(data && data.get("schema") && data.get("schema").get("style")){
          return data.get("schema").get("style");
        } else {
          return '';
        }
      }

      /** Return the parsed HTML date type */
      _parseHTMLDateType(data) {
        var type = this._getType(data);
        if(type == 'date'){
          return 'date';
        } else if( ['datetime', 'datetime-local', 'timestamp'].indexOf(type) > -1){
          return 'datetime-local';
        }
        return 'text';
      }

      /** Returns the schema type variant */
      _getVariant(data) {
        if(data && data.get("schema") && data.get("schema").get("variant")){
          return  data.get("schema").get("variant").toLowerCase();
        } else {
          return 'default';
        }
      }

      /**
        * Checks if the type, given from the schema, is an HTML primitive type.
        * This is used to know if we can use an HTML tag instead of a custom component
        * to present the data value.
        */
      _isDataOfTypePrimitive(data){
        var primitiveTypes = ['text', 'number'];
        var type = this._getType(data);
        if(type) {
          return primitiveTypes.indexOf( type) > -1;
        } else {
          return true;
        }
      }

      /** Returns true if the data type is a `date` type */
      _isDataOfTypeDate(data) {
        var dateTypes = ['date', 'datetime', 'datetime-local', 'timestamp'];
        var type = this._getType(data);
        return dateTypes.indexOf(type) > -1;
      }

      /**
        * Returns true if the data is of type `elType`.
        * By default and if the type is not specified, it will return true as if `elType` == 'text'
        */
      _isDataOfType(data, typeToCheck){
        var type = this._getType(data);
        if( ["bool", "checkbox", "boolean"].indexOf(type) > -1){
          type = "checkbox";
        }

        if(type){
          return type == typeToCheck;
        } else {
          return typeToCheck == 'text';
        }
      }

      /**
       * Should display the data value. Eg: the icon should not display its string
       */
      _shouldShowValue(data) {
        var type = this._getType(data);
        if (type != "icon") {
          return true;
        }
        return false;
      }

      _getIconName(_suggestionsByLabel, _value) {
        var icon = _value;
        if(_suggestionsByLabel && _suggestionsByLabel[_value]) {
          icon = _suggestionsByLabel[_value];
        }
        return icon;
      }

      _getFlagName(_suggestionsByLabel, _value){
        var flag = _value;
        if(_suggestionsByLabel && _suggestionsByLabel[_value]) {
          flag = _suggestionsByLabel[_value];
        }
        return flag;
      }

      _formatValue(data, _value, _suggestions){
        if(_value == undefined){ return _value; }
        var value = this._getLabelFromValue(_suggestions, _value);
        var type = this._getType(data);
        var variant = this._getVariant(data);
        if( type == 'number' && variant == 'financial') {
          return this._financialNumber(value);
        } else if( type == 'number' && variant == 'percentage') {
          return this._percentageNumber(value);
        } else if( ['date', 'datetime-local', 'timestamp'].indexOf(type) > -1) {
          var date = new Date(value);
          var day = (date.getDate()+"").length > 1 ? date.getDate() : '0'+date.getDate();
          var month = ((date.getMonth()+1)+"").length > 1 ? (date.getMonth()) : '0'+(date.getMonth()+1);
          var year = date.getFullYear();
          var hours = (date.getHours()+"").length > 1 ? (date.getHours()) : '0'+date.getHours();
          var minutes = (date.getMinutes()+"").length > 1 ? (date.getMinutes()) : '0'+date.getMinutes();
          var string = day+"."+month+"."+year;
          if( type != 'date') {
            string += " "+hours+":"+minutes;
          }
          return string;
        }
        return value;
      }

      _formatHTMLDatetime(data, _value){
        var type = this._getType(data);
        var date = new Date(_value);
        var day = (date.getDate()+"").length > 1 ? date.getDate() : '0'+date.getDate();
        var month = ((date.getMonth()+1)+"").length > 1 ? (date.getMonth()) : '0'+(date.getMonth()+1);
        var year = date.getFullYear();
        var hours = (date.getHours()+"").length > 1 ? (date.getHours()) : '0'+date.getHours();
        var minutes = (date.getMinutes()+"").length > 1 ? (date.getMinutes()) : '0'+date.getMinutes();
        var string = year+"-"+month+"-"+day;
        if( type != 'date') {
          string += " "+hours+":"+minutes;
        }
        string = string.replace(' ', 'T');
        return string;
      }

      _financialNumber(x) {
        var parts = x.toString().split(".");
        parts[0] = parts[0].replace(/\B(?=(\d{3})+(?!\d))/g, "'");
        parts[1] = (parseFloat("0."+parts[1]).toFixed(2).split("."))[1] || "00";
        return parts.join(".");
      }

      _percentageNumber(x) {
        return x !== undefined ? (parseFloat(x) * 100).toFixed(2) + " %" : x;
      }

      __equals(a, b) {
        return a == b;
      }

      /**
       * Retrieves the suggestion label from the value if exists.
       * Else it returns the value
       */
      _getLabelFromValue(_suggestions, _value) {
        var label = _value;
        if(_suggestions){
          _suggestions.forEach( (s) => {
            if(s.value == _value) { label = s.label; }
          });
        }
        return label;
      }

      _getTextStyle(data, _value){
        if(_value == undefined){ return ""; }
        var type = this._getType(data);
        var variant = this._getVariant(data);
        var style = this._getStyle(data);
        if(type == "number" && variant == "financial"){
          if(_value > 0){
            return "color: yellowgreen;"+style;
          } else if( _value < 0) {
            return "color: indianred;"+style;
          }
        }
        return style;
      }

      empty(){
        this.data = this.data.set("value", "");
        this._forceValue("");
      }
    }
    window.customElements.define(DataScalars.is, DataScalars);
  </script>
</dom-module>
